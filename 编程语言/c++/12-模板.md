
# 模板

> 泛型编程， 函数模板和类模板

## 函数模板
> template<typename T>  
> template<class T>
``` 
template<typename T> 
void mySwap(T &a, T &b){
    T temp = a;
    a = b;
    b = temp;
}
// 1. 自动类型推导
mySwap(a, b);

// 2. 显示指定类型
mySwap<int>(a, b);
```
## 注意事项
``` 
template<class T>
void mySwap(T &a, T &b){
    T temp = a;
    a = b;
    b = temp;
}
mySwap(a, b);

template<class T>
void test(){ 
    cout<< "hello" <<endl;
}
test<int>();

---
class Person{
public:
    string name;
    int age;
};

template<> bool myCompare(Person &p1, Person &p2){
    if(p1.name == p2. name && p1.age == p2.age){
        return true;
    }
    retunr false;
}
```

## 类模板
> 调用时候在创建
``` 
template<class NameType, class AgeType>
class Person{
    public:
        Person(NameType name, AgeType age){
            this->name = name;
            this->age = age;
        }
        NameType name;
        AgeType age;
};

Person<string, int> p1("A", 213);

```

### 类模板对象做函数参数
> 1. 指定传入类型   
> 2. 参数模板化   
> 3. 整个类模板化
``` 
void print(Person<string, int> &p){

}

template<class T1, class T2>
void print2(Person<T1, T2> &p){

}

template<T>
void print2(T &p){

}
```

### 类模板与继承
``` 
template<class T>
class Base{
    T m;
};

class Son : public Base<string>{
    T1 obj;
};

template<class T1, class T2>
class Son2 : public Base<T2>{
    T1 obj;
};

Son2<itn, char> s2;
```

### 类模板成员函数类外实现
``` 
template<class T1, class T2>
class Person{
public:
    Person(T1 name, T2 age);
    //{
    //    
    //}
    void toPring();
    T1 name;
    T2 age;
};
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age){
    this->name = name;
    this->age = age;
}

template<class T1, class T2>
void Person<T1, T2>::print(){
    cout<< this->name << thia->age <<endl;
}


```

### 类模板分文件编写
> 问题：类模板中成员函数创建实际实在调用阶段， 导致分文件编写时链接不到
``` 
// 解决方案一，直接包含.cpp源文件
template<class T1, class T2>
class Person{
public:
    Person(T1 name, T2 age);
    //{
    //    
    //}
    void toPring();
    T1 name;
    T2 age;
};
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age){
    this->name = name;
    this->age = age;
}
template<class T1, class T2>
void Person<T1, T2>::print(){
    cout<< this->name << thia->age <<endl;
}


==== .h
template<class T1, class T2>
class Person{
public:
    Person(T1 name, T2 age);
    //{
    //    
    //}
    void toPring();
    T1 name;
    T2 age;
};

==== person.cpp
#include"person.cpp"
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age){
    this->name = name;
    this->age = age;
}
template<class T1, class T2>
void Person<T1, T2>::print(){
    cout<< this->name << thia->age <<endl;
}

// 解决方案二，将申明.h和实现.cpp写道同一个文件中，并更改后缀名为.hpp, hpp是约定名称
#include "person.hpp"

```

